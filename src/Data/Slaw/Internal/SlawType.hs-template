-- See doc/template.txt for more information about template files.

module Data.Slaw.Internal.SlawType
  ( Slaw(..)
  , NumericFormat(..)
  , NumericData(..)
  , VectorType(..)
  , Symbol
  , RudeData
  , BinarySlaw
  , ErrPair
  , describeSlaw
  , removeDups
  , NumericType(..)
  , extractNumeric
  , restoreNumeric
  , integerToNum
  , NumElem(..)
  , describeNumericFormat
  , describeNumericData
  , describeNumeric
  , numToList
  , intCoerce
  , halfCoerce
  , floatCoerce
  , doubleCoerce
  , NumTyp(..)
  , classifyNumeric
  , numericDataSlice
  , numericDataLength
  ) where

import Control.Arrow (second)
import Control.DeepSeq
-- import Control.Exception
import qualified Data.ByteString      as B
import qualified Data.ByteString.Lazy as L
import Data.Default.Class
import Data.Containers.ListUtils (nubOrd)
import Data.Hashable
import qualified Data.HashMap.Strict     as HM
import Data.Int
import Data.List
-- import qualified Data.Map.Strict      as M
import Data.Maybe
-- import qualified Data.Text            as T
import qualified Data.Vector.Storable as S
import Data.Word
import Foreign.Storable
import GHC.Generics (Generic)
-- import GHC.Stack
import Numeric.Half
import System.IO.Unsafe (unsafePerformIO)

import Data.Slaw.Internal.Exception
import Data.Slaw.Internal.String
import Data.Slaw.Internal.Util
import Data.Slaw.Internal.VectorConvert

type Symbol     = Word64
type RudeData   = L.ByteString
type BinarySlaw = L.ByteString
type ErrPair    = (String, ErrLocation)

data Slaw = SlawProtein     (Maybe Slaw) (Maybe Slaw) RudeData
          | SlawBool        !Bool
          | SlawNil
          | SlawSymbol      !Symbol
          | SlawString      Utf8Str
          | SlawList        [Slaw]
          | SlawMap         [(Slaw, Slaw)]
          | SlawCons        Slaw Slaw
          | SlawNumeric     !NumericFormat NumericData
          | SlawError       String         ErrLocation
          deriving (Eq, Ord, Show, Generic, NFData, Hashable)

instance Monoid Slaw where
  mempty = SlawNil
  mconcat = catSlaw . filter (not . isNil)

instance Semigroup Slaw where
  x <> y = mconcat [x, y]

data NumericFormat = NumericFormat
  { nfArray   :: !Bool
  , nfComplex :: !Bool
  , nfVector  :: !VectorType
  } deriving (Eq, Ord, Show, Generic, NFData, Hashable)

instance Default NumericFormat where
  def = NumericFormat
        { nfArray   = False
        , nfComplex = False
        , nfVector  = VtScalar
        }

data NumericData =
--FOR sizedInt, floating
  BAR NumNAMEXX (S.Vector TYPE)
--END
  deriving (Eq, Ord, Show, Generic, NFData)

instance Hashable NumericData where
--FOR sizedInt
  salt `hashWithSalt` NumNAMEXX v = hh v salt UNIQ `hashRawVector` v
--END
  salt `hashWithSalt` NumHalf   v = hh v salt  666 ## halfList v
--FOR Float, Double
  salt `hashWithSalt` NumNAMEXX v = hh v salt UNIQ ## S.toList v
--END

hh :: Storable a => S.Vector a -> Int -> Int -> Int
hh v salt slug = salt ## (37619* slug) ## S.length v

hashRawVector :: Storable a => Int -> S.Vector a -> Int
hashRawVector salt v
  | len == 0  = salt ## (0xdefacedbadfacade :: Word64)
  | otherwise = unsafePerformIO $ S.unsafeWith v $ \ptr -> do
      let byteLen = len * sizeOf (S.head v)
      hashPtrWithSalt ptr byteLen salt
  where len = S.length v

halfList :: S.Vector Half -> [Word16]
halfList = map f . S.toList
  where f half
          | isZero half = 0
          | otherwise   = (fromIntegral . getHalf) half

data NumericType =
--FOR sizedInt, floating
  BAR TypNAME
--END
  deriving (Eq, Ord, Show, Read, Bounded, Enum, Generic, NFData, Hashable)

data VectorType = VtScalar
                | Vt2
                | Vt3
                | Vt4
                | Vt2mv
                | Vt3mv
                | Vt4mv
                | Vt5mv
                deriving (Eq, Ord, Show, Read, Bounded, Enum,
                          Generic, NFData, Hashable)

describeNumericData :: NumericData -> String
--FOR sizedInt
describeNumericData (NumNAMEXX _) = "BITS-bit SIGNED integer"
--FOR floating
describeNumericData (NumNAMEXX _) = "BITS-bit floating point"
--END

describeNumericFormat :: NumericFormat -> [String]
describeNumericFormat nf = concat [d1, d2, d3]
  where d1 = if nfArray nf then ["array of"] else []
        d2 = describeVectorType $ nfVector nf
        d3 = if nfComplex nf then ["complex"] else []

describeVectorType :: VectorType -> [String]
describeVectorType VtScalar = []
describeVectorType Vt2   = ["2-vector of"]
describeVectorType Vt3   = ["3-vector of"]
describeVectorType Vt4   = ["4-vector of"]
describeVectorType Vt2mv = ["2-multivector of"]
describeVectorType Vt3mv = ["3-multivector of"]
describeVectorType Vt4mv = ["4-multivector of"]
describeVectorType Vt5mv = ["5-multivector of"]

describeNumeric :: NumericFormat -> NumericData -> String
describeNumeric nf nd = intercalate " " (nfl ++ [nds])
  where nfl = describeNumericFormat nf
        nds = describeNumericData   nd

describeSlaw :: Slaw -> String
describeSlaw (SlawProtein _ _ _) = "protein"
describeSlaw (SlawBool    b    ) = "boolean " ++ show b
describeSlaw (SlawNil          ) = "nil"
describeSlaw (SlawSymbol  s    ) = "symbol " ++ show s
describeSlaw (SlawString  _    ) = "string"
describeSlaw (SlawList    _    ) = "list"
describeSlaw (SlawMap     _    ) = "map"
describeSlaw (SlawCons    _ _  ) = "cons"
describeSlaw (SlawNumeric nf nd) = describeNumeric nf nd
describeSlaw (SlawError   _ _  ) = "error"

dnf :: NumericFormat -> String
dnf nf = case describeNumericFormat nf of
           [] -> "scalar"
           xs -> let str      = intercalate " " xs
                     len      = length str
                     sfx      = " of"
                     sfxLen   = length sfx
                     (s1, s2) = splitAt (len - sfxLen) str
                 in if sfx == s2 then s1 else str

isNil :: Slaw -> Bool
isNil SlawNil = True
isNil _       = False

nowhere :: ErrLocation
nowhere = ErrLocation DsNone Nothing

cantCat :: String -> String -> ErrPair
cantCat s1 s2 = (msg, nowhere)
  where
    msg = concat [typeMismatchPfx, "Can't concatenate ", s1, " and ", s2]

catSlaw :: [Slaw] -> Slaw
catSlaw []                          = SlawNil
catSlaw [s]                         = s
catSlaw (s@(SlawError   _ _)   : _) = s
catSlaw ss@(SlawProtein _ _ _  : _) = doCat getProtein      catProteins ss
catSlaw ss@(SlawString  _      : _) = doCat getString       catStrings  ss
catSlaw ss@(SlawList    _      : _) = doCat getList         catLists    ss
catSlaw ss@(SlawMap     _      : _) = doCat getMap          catMaps     ss
catSlaw ss@(SlawNumeric nf _   : _) = doCat (getNumeric nf) (catNumeric nf) ss
catSlaw (_ : s@(SlawError _ _) : _) = s
catSlaw (s1 : s2               : _) =
  (uncurry SlawError) (describeSlaw s1 `cantCat` describeSlaw s2)

doCat :: (Slaw -> Either ErrPair a)
      -> ([a] -> Slaw)
      -> [Slaw]
      -> Slaw
doCat chkFunc catFunc ss =
  case mapM chkFunc ss of
    Left (msg, loc) -> SlawError msg loc
    Right xs        -> catFunc   xs

getString :: Slaw -> Either ErrPair Utf8Str
getString (SlawString lbs    ) = Right lbs
getString (SlawError  msg loc) = Left (msg, loc)
getString s                    = Left $ "string" `cantCat` describeSlaw s

getList :: Slaw -> Either ErrPair [Slaw]
getList (SlawList   ss     ) = Right ss
getList (SlawError  msg loc) = Left (msg, loc)
getList s                    = Left $ "list" `cantCat` describeSlaw s

getMap :: Slaw -> Either ErrPair [(Slaw, Slaw)]
getMap (SlawMap   ss)                        = Right ss
getMap (SlawProtein _ (Just (SlawMap ss)) _) = Right ss
getMap (SlawError msg loc)                   = Left  (msg, loc)
getMap s               = Left $ "map" `cantCat` describeSlaw s

getNumeric :: NumericFormat -> Slaw -> Either ErrPair NumericData
getNumeric nf0 (SlawNumeric nf  nd ) =
  if nfComplex nf0 == nfComplex nf && nfVector nf0 == nfVector nf
  then Right nd
  else Left $ dnf nf0 `cantCat` dnf nf
getNumeric _   (SlawError   msg loc) = Left (msg, loc)
getNumeric nf0  s                    =
  Left $ dnf nf0 `cantCat` describeSlaw s

getProtein :: Slaw -> Either ErrPair (Maybe Slaw, Maybe Slaw, RudeData)
getProtein (SlawProtein des ing rude) = Right (des, ing, rude)
getProtein s@(SlawMap   _           ) = Right (Nothing, Just s, mempty)
getProtein (SlawError   msg loc     ) = Left  (msg, loc)
getProtein s = Left $ "protein" `cantCat` describeSlaw s

catProteins :: [(Maybe Slaw, Maybe Slaw, RudeData)] -> Slaw
catProteins triples = SlawProtein des' ing' rude'
  where
    (dess, ings, rudes) = unzip3 triples
    dess'  = catMaybes dess
    ings'  = catMaybes ings
    rudes' = filter (not . L.null) rudes
    des'   = case mconcat dess' of
               SlawNil     -> Nothing
               SlawList ss -> (Just . SlawList . nubOrd) ss
               s           -> Just s
    ing'   = case mconcat ings' of
               SlawNil     -> Nothing
               s           -> Just s
    rude'  = last (L.empty : rudes')

catStrings :: [Utf8Str] -> Slaw
catStrings = SlawString . mconcat

catLists :: [[Slaw]] -> Slaw
catLists = SlawList  . concat

catMaps :: [[(Slaw, Slaw)]] -> Slaw
catMaps = SlawMap . removeDups . concat

-- Remove duplicate keys while preserving order.
-- Keeps the *last* value for a key, but at the position
-- where the key *first* appeared.
removeDups :: [(Slaw, Slaw)] -> [(Slaw, Slaw)]
removeDups pairs = map (second snd) l4
  where pairs1      = zipWith f1 pairs [(1 :: Word64)..]
        f1 (k, v) n = (k, (n, v))
        hm          = HM.fromListWith f2 pairs1
        f2 (_, newV) (oldN, _) = (oldN, newV)
        l3          = HM.toList hm
        l4          = sortOn (fst . snd) l3

catNumeric :: NumericFormat -> [NumericData] -> Slaw
catNumeric nf nds = SlawNumeric nf' nd
  where
    bo          = nativeByteOrder
    nf'         = nf { nfArray = True }
    pairs       = map (extractNumeric bo) nds
    (typs, bss) = unzip pairs
    typ0        = head typs
    sameType    = all (== typ0) typs
    nd          = if sameType
                  then restoreNumeric bo typ0 $ mconcat bss
                  else listToNum $ concatMap numToList nds

extractNumeric :: ByteOrder -> NumericData -> (NumericType, B.ByteString)
--FOR sizedInt, floating
extractNumeric bo (NumNAMEXX v) = (TypNAMEXX, vToBs bo v)
--END

restoreNumeric :: ByteOrder -> NumericType -> B.ByteString -> NumericData
--FOR sizedInt, floating
restoreNumeric bo TypNAMEXX bs = NumNAMEXX (bsToV bo bs)
--END

data NumElem = ElemInt    !Integer
--FOR floating
             | ElemTYPEXX !TYPE
--END
             deriving (Eq, Ord, Show, Generic, NFData)

data NumRange = RangeInt  { rangeLo :: !Integer, rangeHi :: !Integer }
--FOR floating
              | RangeTYPE
--END
              deriving (Eq, Ord, Show, Generic, NFData, Hashable)

numToList :: NumericData -> [NumElem]
--FOR sizedInt
numToList (NumNAMEXX v) = intToList   v
--FOR floating
numToList (NumNAMEXX v) = LTYPEToList v
--END

intToList :: (Integral a, Storable a) => S.Vector a -> [NumElem]
intToList = map (ElemInt . toInteger) . S.toList

--FOR floating
LTYPEToList :: S.Vector TYPE -> [NumElem]
LTYPEToList = map ElemTYPE . S.toList
--END

listToNum :: [NumElem] -> NumericData
listToNum nes =
  let range = foldl' addToRange (baseRange nes) nes
      typ   = typeFromRange range
  in typeToNum typ nes

baseRange :: [NumElem] -> NumRange
baseRange []                 = RangeInt 0 0 -- shouldn't happen
baseRange (ElemInt    x : _) = RangeInt x x
--FOR floating
baseRange (ElemTYPEXX _ : _) = RangeTYPE
--END

addToRange :: NumRange -> NumElem -> NumRange
addToRange RangeDouble      _              = RangeDouble
addToRange _                (ElemDouble _) = RangeDouble
addToRange (RangeInt lo hi) (ElemInt x)    = RangeInt lo' hi'
  where lo' = lo `min` x
        hi' = hi `max` x
addToRange RangeFloat       (ElemFloat _)  = RangeFloat
addToRange RangeHalf        (ElemHalf  _)  = RangeHalf
addToRange RangeFloat       (ElemHalf _)   = RangeFloat
addToRange RangeHalf        (ElemFloat _)  = RangeFloat
addToRange RangeFloat       (ElemInt x)
  | fitsInFloat x                          = RangeFloat
  | otherwise                              = RangeDouble
addToRange (RangeInt lo hi) (ElemFloat _)
  | fitsInFloat lo && fitsInFloat hi       = RangeFloat
  | otherwise                              = RangeDouble
addToRange RangeHalf        (ElemInt x)
  | fitsInHalf  x                          = RangeHalf
  | fitsInFloat x                          = RangeFloat
  | otherwise                              = RangeDouble
addToRange (RangeInt lo hi) (ElemHalf _)
  | fitsInHalf  lo && fitsInHalf  hi       = RangeHalf
  | fitsInFloat lo && fitsInFloat hi       = RangeFloat
  | otherwise                              = RangeDouble

fitsInHalf :: Integer -> Bool
fitsInHalf x = abs x <= 2048

fitsInFloat :: Integer -> Bool
fitsInFloat x = abs x <= 0x1_00_00_00

typeFromRange :: NumRange -> NumericType
--FOR floating
typeFromRange RangeTYPEXX = TypTYPE
--END
typeFromRange (RangeInt lo hi) =
  case find (checkRange lo hi) ranges of
    Nothing       -> TypDouble
    Just (_, typ) -> typ

checkRange :: Integer
           -> Integer
           -> ((Integer, Integer), a)
           -> Bool
checkRange lo hi ((lo', hi'), _) = lo >= lo' && hi <= hi'

ranges :: [((Integer, Integer), NumericType)]
ranges =
  [
--FOR sizedInt
  COMMA mkRange (0 :: TYPEXX) TypNAME
--END
  ]

mkRange :: (Integral a, Bounded a)
        => a
        -> NumericType
        -> ((Integer, Integer), NumericType)
mkRange dummy typ = ((toInteger lo, toInteger hi), typ)
  where lo = minBound `asTypeOf` dummy
        hi = maxBound `asTypeOf` dummy

typeToNum :: NumericType -> [NumElem] -> NumericData
--FOR sizedInt
typeToNum TypNAMEXX = NumNAMEXX . S.fromList . map intCoerce
--FOR floating
typeToNum TypNAMEXX = NumNAMEXX . S.fromList . map LTYPECoerce
--END

intCoerce :: (Integral a, Storable a) => NumElem -> a
intCoerce (ElemInt    x) = fromInteger x
intCoerce (ElemHalf   x) = round       x
intCoerce (ElemFloat  x) = round       x
intCoerce (ElemDouble x) = round       x

halfCoerce :: NumElem -> Half
halfCoerce (ElemInt    x) = fromInteger             x
halfCoerce (ElemHalf   x) =                         x
halfCoerce (ElemFloat  x) = toHalf                  x
halfCoerce (ElemDouble x) = (toHalf . double2Float) x

floatCoerce :: NumElem -> Float
floatCoerce (ElemInt    x) = fromInteger  x
floatCoerce (ElemHalf   x) = fromHalf     x
floatCoerce (ElemFloat  x) =              x
floatCoerce (ElemDouble x) = double2Float x

doubleCoerce :: NumElem -> Double
doubleCoerce (ElemInt    x) = fromInteger               x
doubleCoerce (ElemHalf   x) = (float2Double . fromHalf) x
doubleCoerce (ElemFloat  x) = float2Double              x
doubleCoerce (ElemDouble x) =                           x

integerToNum :: Integer -> Maybe NumericData
integerToNum n =
  case listToNum [ElemInt n] of
--FOR floating
    NumTYPEXX _ -> Nothing
--END
    nd          -> Just nd

data NumTyp =
    NumTypSigned   -- 0
  | NumTypUnsigned -- 1
  | NumTypFloat    -- 2
  deriving (Eq, Ord, Show, Read, Bounded, Enum, Generic, NFData, Hashable)

classifyNumeric :: NumericType -> (NumTyp, Int)
--FOR sizedInt, floating
classifyNumeric TypNAMEXX = (NumTypSIGNEDXX, BITS `div` 8)
--END

numericDataSlice :: Int -> Int -> NumericData -> NumericData
--FOR sizedInt, floating
numericDataSlice i n (NumNAMEXX v) = NumNAMEXX (S.slice i n v)
--END

numericDataLength :: NumericData -> Int
--FOR sizedInt, floating
numericDataLength (NumNAMEXX v) = S.length v
--END

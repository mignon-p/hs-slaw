-- See doc/template.txt for more information about template files.

{-# LANGUAGE RankNTypes                 #-}

module Data.Slaw.Internal.SlawType
  ( Slaw(..)
  , NumericFormat(..)
  , NumericData(..)
  , VectorType(..)
  , Symbol
  , RudeData
  , BinarySlaw
  , ErrPair
  , describeSlaw
  -- , removeDups
  , NumericType(..)
  , extractNumeric
  , restoreNumeric
  , integerToNum
  , NumElem(..)
  , describeNumericFormat
  , describeNumericData
  , describeNumeric
  , numToList
  , intCoerce
  , halfCoerce
  , floatCoerce
  , doubleCoerce
  , NumTyp(..)
  , classifyNumeric
  , isNumericFormatLegal
  ) where

import Control.DeepSeq
import Control.Exception
import Data.Bifunctor
import qualified Data.ByteString      as B
import qualified Data.ByteString.Lazy as L
import Data.Complex
import Data.Containers.ListUtils (nubOrd)
import Data.Default.Class
import Data.Hashable
import qualified Data.HashMap.Strict     as HM
import Data.Int
import Data.List
-- import qualified Data.Map.Strict      as M
import Data.Maybe
import Data.Ratio
import Data.String
-- import qualified Data.Text            as T
import qualified Data.Vector.Storable as S
import Data.Word
import Foreign.Storable
import GHC.Generics (Generic)
import GHC.Stack
import Numeric.Half
import System.IO.Unsafe (unsafePerformIO)
import Text.Read

import Data.Slaw.Internal.Exception
import Data.Slaw.Internal.HalfOrphans ()
import Data.Slaw.Internal.String
import Data.Slaw.Internal.Util
import Data.Slaw.Internal.VectorConvert

type Symbol     = Word64
type RudeData   = L.ByteString
type BinarySlaw = L.ByteString
type ErrPair    = (String, ErrLocation)

data Slaw = SlawProtein     (Maybe Slaw) (Maybe Slaw) RudeData
          | SlawBool        !Bool
          | SlawNil
          | SlawSymbol      !Symbol
          | SlawString      Utf8Str
          | SlawList        [Slaw]
          | SlawMap         [(Slaw, Slaw)]
          | SlawCons        Slaw Slaw
          | SlawNumeric     !NumericFormat NumericData
          | SlawError       String         ErrLocation
          deriving (Eq, Ord, Show, Generic, NFData, Hashable)

instance Monoid Slaw where
  mempty = SlawNil
  mconcat = catSlaw . filter (not . isNil)

instance Semigroup Slaw where
  x <> y = mconcat [x, y]

instance IsString Slaw where
  fromString = SlawString . toUtf8

data NumericFormat = NumericFormat
  { nfArray   :: !Bool
  , nfComplex :: !Bool
  , nfVector  :: !VectorType
  } deriving (Eq, Ord, Show, Generic, NFData, Hashable)

instance Default NumericFormat where
  def = NumericFormat
        { nfArray   = False
        , nfComplex = False
        , nfVector  = VtScalar
        }

data NumericData =
--FOR sizedInt, floating
  BAR NumNAMEXXX (S.Vector TYPE)
--END
  deriving (Eq, Ord, Show, Generic, NFData)

instance Hashable NumericData where
--FOR sizedInt
  salt `hashWithSalt` NumNAMEXXX v = hh v salt UNIQ `hashRawVector` v
--FOR floating
  salt `hashWithSalt` NumNAMEXXX v = hh v salt UNIQ ## S.toList v
--END

hh :: Storable a => S.Vector a -> Int -> Int -> Int
hh v salt slug = salt ## (37619* slug) ## S.length v

hashRawVector :: Storable a => Int -> S.Vector a -> Int
hashRawVector salt v
  | len == 0  = salt ## (0xdefacedbadfacade :: Word64)
  | otherwise = unsafePerformIO $ S.unsafeWith v $ \ptr -> do
      let byteLen = len * sizeOf (S.head v)
      hashPtrWithSalt ptr byteLen salt
  where len = S.length v

data NumericType =
--FOR sizedInt, floating
  BAR TypNAME
--END
  deriving (Eq, Ord, Show, Read, Bounded, Enum, Generic, NFData, Hashable)

data VectorType = VtScalar
                | Vt2
                | Vt3
                | Vt4
                | Vt2mv
                | Vt3mv
                | Vt4mv
                | Vt5mv
                deriving (Eq, Ord, Show, Read, Bounded, Enum,
                          Generic, NFData, Hashable)

describeNumericData :: NumericData -> String
--FOR sizedInt
describeNumericData (NumNAMEXXX _) = "BITS-bit SIGNED integer"
--FOR floating
describeNumericData (NumNAMEXXX _) = "BITS-bit floating point"
--END

describeNumericFormat1 :: NumericFormat -> [String]
describeNumericFormat1 nf = concat [d1, d2, d3]
  where d1 = if nfArray nf then ["array of"] else []
        d2 = describeVectorType $ nfVector nf
        d3 = if nfComplex nf then ["complex"] else []

describeVectorType :: VectorType -> [String]
describeVectorType VtScalar = []
describeVectorType Vt2   = ["2-vector of"]
describeVectorType Vt3   = ["3-vector of"]
describeVectorType Vt4   = ["4-vector of"]
describeVectorType Vt2mv = ["2-multivector of"]
describeVectorType Vt3mv = ["3-multivector of"]
describeVectorType Vt4mv = ["4-multivector of"]
describeVectorType Vt5mv = ["5-multivector of"]

describeNumeric :: NumericFormat -> NumericData -> String
describeNumeric nf nd = intercalate " " (nfl ++ [nds])
  where nfl = describeNumericFormat1 nf
        nds = describeNumericData    nd

describeSlaw :: Slaw -> String
describeSlaw (SlawProtein _ _ _) = "protein"
describeSlaw (SlawBool    b    ) = "boolean " ++ show b
describeSlaw (SlawNil          ) = "nil"
describeSlaw (SlawSymbol  s    ) = "symbol " ++ show s
describeSlaw (SlawString  _    ) = "string"
describeSlaw (SlawList    _    ) = "list"
describeSlaw (SlawMap     _    ) = "map"
describeSlaw (SlawCons    _ _  ) = "cons"
describeSlaw (SlawNumeric nf nd) = describeNumeric nf nd
describeSlaw (SlawError   _ _  ) = "error"

describeNumericFormat :: NumericFormat -> String
describeNumericFormat nf =
  case describeNumericFormat1 nf of
    [] -> "scalar"
    xs -> let str      = intercalate " " xs
              len      = length str
              sfx      = " of"
              sfxLen   = length sfx
              (s1, s2) = splitAt (len - sfxLen) str
          in if sfx == s2 then s1 else str

isNil :: Slaw -> Bool
isNil SlawNil = True
isNil _       = False

nowhere :: ErrLocation
nowhere = ErrLocation DsNone Nothing

cantCat :: String -> String -> ErrPair
cantCat s1 s2 = (msg, nowhere)
  where
    msg = concat [typeMismatchPfx, "Can't concatenate ", s1, " and ", s2]

catSlaw :: [Slaw] -> Slaw
catSlaw []                          = SlawNil
catSlaw [s]                         = s
catSlaw (s@(SlawError   _ _)   : _) = s
catSlaw ss@(SlawProtein _ _ _  : _) = doCat getProtein      catProteins ss
catSlaw ss@(SlawString  _      : _) = doCat getString       catStrings  ss
catSlaw ss@(SlawList    _      : _) = doCat getList         catLists    ss
catSlaw ss@(SlawMap     _      : _) = doCat getMap          catMaps     ss
catSlaw ss@(SlawNumeric nf _   : _) = doCat (getNumeric nf) (catNumeric nf) ss
catSlaw (_ : s@(SlawError _ _) : _) = s
catSlaw (s1 : s2               : _) =
  (uncurry SlawError) (describeSlaw s1 `cantCat` describeSlaw s2)

doCat :: (Slaw -> Either ErrPair a)
      -> ([a] -> Slaw)
      -> [Slaw]
      -> Slaw
doCat chkFunc catFunc ss =
  case mapM chkFunc ss of
    Left (msg, loc) -> SlawError msg loc
    Right xs        -> catFunc   xs

getString :: Slaw -> Either ErrPair Utf8Str
getString (SlawString lbs    ) = Right lbs
getString (SlawError  msg loc) = Left (msg, loc)
getString s                    = Left $ "string" `cantCat` describeSlaw s

getList :: Slaw -> Either ErrPair [Slaw]
getList (SlawList   ss     ) = Right ss
getList (SlawError  msg loc) = Left (msg, loc)
getList s                    = Left $ "list" `cantCat` describeSlaw s

getMap :: Slaw -> Either ErrPair [(Slaw, Slaw)]
getMap (SlawMap   ss)                        = Right ss
getMap (SlawProtein _ (Just (SlawMap ss)) _) = Right ss
getMap (SlawError msg loc)                   = Left  (msg, loc)
getMap s               = Left $ "map" `cantCat` describeSlaw s

getNumeric :: NumericFormat -> Slaw -> Either ErrPair NumericData
getNumeric nf0 (SlawNumeric nf  nd ) =
  if nfComplex nf0 == nfComplex nf && nfVector nf0 == nfVector nf
  then Right nd
  else Left $ describeNumericFormat nf0 `cantCat` describeNumericFormat nf
getNumeric _   (SlawError   msg loc) = Left (msg, loc)
getNumeric nf0  s                    =
  Left $ describeNumericFormat nf0 `cantCat` describeSlaw s

getProtein :: Slaw -> Either ErrPair (Maybe Slaw, Maybe Slaw, RudeData)
getProtein (SlawProtein des ing rude) = Right (des, ing, rude)
getProtein s@(SlawMap   _           ) = Right (Nothing, Just s, mempty)
getProtein (SlawError   msg loc     ) = Left  (msg, loc)
getProtein s = Left $ "protein" `cantCat` describeSlaw s

catProteins :: [(Maybe Slaw, Maybe Slaw, RudeData)] -> Slaw
catProteins triples = SlawProtein des' ing' rude'
  where
    (dess, ings, rudes) = unzip3 triples
    dess'  = catMaybes dess
    ings'  = catMaybes ings
    rudes' = filter (not . L.null) rudes
    des'   = case mconcat dess' of
               SlawNil     -> Nothing
               SlawList ss -> (Just . SlawList . nubOrd) ss
               s           -> Just s
    ing'   = case mconcat ings' of
               SlawNil     -> Nothing
               s           -> Just s
    rude'  = last (L.empty : rudes')

catStrings :: [Utf8Str] -> Slaw
catStrings = SlawString . mconcat

catLists :: [[Slaw]] -> Slaw
catLists = SlawList  . concat

catMaps :: [[(Slaw, Slaw)]] -> Slaw
catMaps = SlawMap . removeDups . concat

-- Remove duplicate keys while preserving order.
-- Keeps the *last* value for a key, but at the position
-- where the key *first* appeared.
removeDups :: [(Slaw, Slaw)] -> [(Slaw, Slaw)]
removeDups pairs = map (second snd) l4
  where pairs1      = zipWith f1 pairs [(1 :: Word64)..]
        f1 (k, v) n = (k, (n, v))
        hm          = HM.fromListWith f2 pairs1
        f2 (_, newV) (oldN, _) = (oldN, newV)
        l3          = HM.toList hm
        l4          = sortOn (fst . snd) l3

catNumeric :: NumericFormat -> [NumericData] -> Slaw
catNumeric nf nds = SlawNumeric nf' nd
  where
    bo          = nativeByteOrder
    nf'         = nf { nfArray = True }
    pairs       = map (extractNumeric bo) nds
    (typs, bss) = unzip pairs
    typ0        = head typs
    sameType    = all (== typ0) typs
    nd          = if sameType
                  then restoreNumeric bo typ0 $ mconcat bss
                  else listToNum $ concatMap numToList nds

extractNumeric :: ByteOrder -> NumericData -> (NumericType, B.ByteString)
--FOR sizedInt, floating
extractNumeric bo (NumNAMEXXX v) = (TypNAMEXXX, vToBs bo v)
--END

restoreNumeric :: ByteOrder -> NumericType -> B.ByteString -> NumericData
--FOR sizedInt, floating
restoreNumeric bo TypNAMEXXX bs = NumNAMEXXX (bsToV bo bs)
--END

data NumElem = ElemInt    !Integer
--FOR floating
             | ElemTYPEXX !TYPE
--END
             deriving (Eq, Ord, Show, Generic, NFData)

data NumRange = RangeInt  { rangeLo :: !Integer, rangeHi :: !Integer }
--FOR floating
              | RangeTYPE
--END
              deriving (Eq, Ord, Show, Generic, NFData, Hashable)

numToList :: NumericData -> [NumElem]
--FOR sizedInt
numToList (NumNAMEXXX v) = intToList   v
--FOR floating
numToList (NumNAMEXXX v) = LTYPEToList v
--END

intToList :: (Integral a, Storable a) => S.Vector a -> [NumElem]
intToList = map (ElemInt . toInteger) . S.toList

--FOR floating
LTYPEToList :: S.Vector TYPE -> [NumElem]
LTYPEToList = map ElemTYPE . S.toList
--END

listToNum :: [NumElem] -> NumericData
listToNum nes =
  let range = foldl' addToRange (baseRange nes) nes
      typ   = typeFromRange range
  in typeToNum typ nes

baseRange :: [NumElem] -> NumRange
baseRange []                 = RangeInt 0 0 -- shouldn't happen
baseRange (ElemInt    x : _) = RangeInt x x
--FOR floating
baseRange (ElemTYPEXX _ : _) = RangeTYPE
--END

addToRange :: NumRange -> NumElem -> NumRange
addToRange RangeDouble      _              = RangeDouble
addToRange _                (ElemDouble _) = RangeDouble
addToRange (RangeInt lo hi) (ElemInt x)    = RangeInt lo' hi'
  where lo' = lo `min` x
        hi' = hi `max` x
addToRange RangeFloat       (ElemFloat _)  = RangeFloat
addToRange RangeHalf        (ElemHalf  _)  = RangeHalf
addToRange RangeFloat       (ElemHalf _)   = RangeFloat
addToRange RangeHalf        (ElemFloat _)  = RangeFloat
addToRange RangeFloat       (ElemInt x)
  | fitsInFloat x                          = RangeFloat
  | otherwise                              = RangeDouble
addToRange (RangeInt lo hi) (ElemFloat _)
  | fitsInFloat lo && fitsInFloat hi       = RangeFloat
  | otherwise                              = RangeDouble
addToRange RangeHalf        (ElemInt x)
  | fitsInHalf  x                          = RangeHalf
  | fitsInFloat x                          = RangeFloat
  | otherwise                              = RangeDouble
addToRange (RangeInt lo hi) (ElemHalf _)
  | fitsInHalf  lo && fitsInHalf  hi       = RangeHalf
  | fitsInFloat lo && fitsInFloat hi       = RangeFloat
  | otherwise                              = RangeDouble

fitsInHalf :: Integer -> Bool
fitsInHalf x = abs x <= 2048

fitsInFloat :: Integer -> Bool
fitsInFloat x = abs x <= 0x1_00_00_00

typeFromRange :: NumRange -> NumericType
--FOR floating
typeFromRange RangeTYPEXX = TypNAME
--END
typeFromRange (RangeInt lo hi) =
  case find (checkRange lo hi) ranges of
    Nothing       -> TypFloat64
    Just (_, typ) -> typ

checkRange :: Integer
           -> Integer
           -> ((Integer, Integer), a)
           -> Bool
checkRange lo hi ((lo', hi'), _) = lo >= lo' && hi <= hi'

ranges :: [((Integer, Integer), NumericType)]
ranges =
  [
-- Order is important here, so spell it out instead of using "sizedInt"
--FOR Word8, Word16, Word32, Word64, Int8, Int16, Int32, Int64
  COMMA mkRange (0 :: TYPEXX) TypNAME
--END
  ]

mkRange :: (Integral a, Bounded a)
        => a
        -> NumericType
        -> ((Integer, Integer), NumericType)
mkRange dummy typ = ((toInteger lo, toInteger hi), typ)
  where lo = minBound `asTypeOf` dummy
        hi = maxBound `asTypeOf` dummy

typeToNum :: NumericType -> [NumElem] -> NumericData
--FOR sizedInt
typeToNum TypNAMEXXX = NumNAMEXXX . S.fromList . map intCoerce
--FOR floating
typeToNum TypNAMEXXX = NumNAMEXXX . S.fromList . map LTYPECoerce
--END

intCoerce :: (Integral a, Storable a) => NumElem -> a
intCoerce (ElemInt    x) = fromInteger x
intCoerce (ElemHalf   x) = round       x
intCoerce (ElemFloat  x) = round       x
intCoerce (ElemDouble x) = round       x

halfCoerce :: NumElem -> Half
halfCoerce (ElemInt    x) = fromInteger             x
halfCoerce (ElemHalf   x) =                         x
halfCoerce (ElemFloat  x) = toHalf                  x
halfCoerce (ElemDouble x) = (toHalf . double2Float) x

floatCoerce :: NumElem -> Float
floatCoerce (ElemInt    x) = fromInteger  x
floatCoerce (ElemHalf   x) = fromHalf     x
floatCoerce (ElemFloat  x) =              x
floatCoerce (ElemDouble x) = double2Float x

doubleCoerce :: NumElem -> Double
doubleCoerce (ElemInt    x) = fromInteger               x
doubleCoerce (ElemHalf   x) = (float2Double . fromHalf) x
doubleCoerce (ElemFloat  x) = float2Double              x
doubleCoerce (ElemDouble x) =                           x

integerToNum :: Integer -> Maybe NumericData
integerToNum n =
  case listToNum [ElemInt n] of
--FOR floating
    NumNAMEXXX _ -> Nothing
--END
    nd          -> Just nd

data NumTyp =
    NumTypSigned   -- 0
  | NumTypUnsigned -- 1
  | NumTypFloat    -- 2
  deriving (Eq, Ord, Show, Read, Bounded, Enum, Generic, NFData, Hashable)

classifyNumeric :: NumericType -> (NumTyp, Int)
--FOR sizedInt, floating
classifyNumeric TypNAMEXXX = (NumTypSIGNEDXX, BITS `div` 8)
--END

-- all combinations are legal, EXCEPT that you can't be complex and
-- also a multivector
isNumericFormatLegal :: NumericFormat -> Bool
isNumericFormatLegal nf = not legal
  where legal = nfComplex nf && nfVector nf >= Vt2mv

               -- Num and Fractional instances for Slaw --

instance Num Slaw where
  (+)          = numBinOp    (+)    "(+)"
  (-)          = numBinOp    (-)    "(-)"
  (*)          = numBinOp    (*)    "(*)"
  negate       = numUnOp     negate "negate"
  abs          = numUnOp     abs    "abs"
  signum       = numUnOp     signum "signum"
  fromInteger  = argToSlaw . OpArgInt

instance Fractional Slaw where
  (/)          = fracBinOp   (/)    "(/)"
  recip        = fracUnOp    recip  "recip"
  fromRational = argToSlaw . OpArgDouble . fromRational

data OpArg = OpArgInt     !Integer
           | OpArgDouble  !Double
           | OpArgComplex !(Complex Double)

data ArgPair = ArgPairInt     !Integer          !Integer
             | ArgPairDouble  !Double           !Double
             | ArgPairComplex !(Complex Double) !(Complex Double)

promote :: OpArg -> OpArg -> ArgPair
promote (OpArgInt x) (OpArgInt     y) = ArgPairInt           x  y
promote (OpArgInt x) (OpArgDouble  y) = ArgPairDouble  (dbl  x) y
promote (OpArgInt x) (OpArgComplex y) = ArgPairComplex (cplx x) y

promote (OpArgDouble x) (OpArgInt     y) = ArgPairDouble   x    (dbl y)
promote (OpArgDouble x) (OpArgDouble  y) = ArgPairDouble   x         y
promote (OpArgDouble x) (OpArgComplex y) = ArgPairComplex (x :+ 0)   y

promote (OpArgComplex x) (OpArgInt     y) = ArgPairComplex x   (cplx y)
promote (OpArgComplex x) (OpArgDouble  y) = ArgPairComplex x   (y :+ 0)
promote (OpArgComplex x) (OpArgComplex y) = ArgPairComplex x    y

dbl :: Integer -> Double
dbl = fromInteger

cplx :: Integer -> Complex Double
cplx = (:+ 0) . fromInteger

slawToArg :: HasCallStack => String -> Slaw -> OpArg
slawToArg op s =
  case slawToArg0 op s of
    Left  exc -> throw $ exc { peCallstack = Just callStack }
    Right arg -> arg

slawToArg0 :: String -> Slaw -> Either PlasmaException OpArg
slawToArg0 op (SlawError msg loc) =
  Left $ def { peType     = etFromMsg msg
             , peMessage  = msg'
             , peLocation = Just loc
             }
  where msg' = concat [ "Argument to "
                      , op
                      , " was an error:\n"
                      , indentLines stdIndent msg
                      ]
slawToArg0 op s = first   typeMismatch $ slawToArg' op s

slawToArg' :: String -> Slaw -> Either String OpArg
slawToArg' op (SlawString    lbs) =
  let str = fromUtf8 lbs
  in case (readMaybe str, readMaybe str) of
       (Just i,  _     ) -> Right $ OpArgInt    i
       (Nothing, Just d) -> Right $ OpArgDouble d
       _                 -> Left  $ slawOpErr op $ show str
slawToArg' op (SlawCons  car cdr) =
  case (slawToArg' op car, slawToArg' op cdr) of
    (Right (OpArgInt num), Right (OpArgInt den)) ->
      Right $ OpArgDouble $ fromRational $ num % den
    _ -> Left $ slawOpErr op $ concat [ "cons ("
                                      , describeSlaw car
                                      , ", "
                                      , describeSlaw cdr
                                      , ")"
                                      ]
slawToArg' op (SlawNumeric nf nd) =
  case (nfComplex nf, numToList nd) of
    (False, [ElemInt i]) -> Right $ OpArgInt i
    (False, [x]        ) -> Right $ OpArgDouble $ doubleCoerce x
    (True,  [re, im]   ) ->
      Right $ OpArgComplex $ doubleCoerce re :+ doubleCoerce im
    _                    -> Left $ slawOpErr op $ describeNumeric nf nd
slawToArg' op s = Left $ slawOpErr op $ describeSlaw s

slawOpErr :: String -> String -> String
slawOpErr op arg = concat [ "Unable to use "
                          , arg
                          , " as an argument to "
                          , op
                          ]

argToSlaw :: OpArg -> Slaw
argToSlaw (OpArgInt    i) =
  case integerToNum i of
    Just nd -> SlawNumeric def nd
    Nothing -> (SlawString . toUtf8 . show) i
argToSlaw (OpArgDouble d) =
  SlawNumeric def $ NumFloat64 $ S.singleton d
argToSlaw (OpArgComplex (re :+ im)) =
  SlawNumeric nfCplx $ NumFloat64 $ S.fromList [re, im]
  where nfCplx = def { nfComplex = True }

numOp :: (forall a. (Num a) => a -> a -> a)
      -> OpArg -> OpArg -> Slaw
numOp f x y = argToSlaw $ g $ promote x y
  where g (ArgPairInt     x' y') = OpArgInt     $ f x' y'
        g (ArgPairDouble  x' y') = OpArgDouble  $ f x' y'
        g (ArgPairComplex x' y') = OpArgComplex $ f x' y'

fracOp :: (forall a. (Fractional a) => a -> a -> a)
       -> OpArg -> OpArg -> Slaw
fracOp f x y = argToSlaw $ g $ promote x y
  where g (ArgPairInt     x' y') = OpArgDouble  $ f (dbl x') (dbl y')
        g (ArgPairDouble  x' y') = OpArgDouble  $ f x' y'
        g (ArgPairComplex x' y') = OpArgComplex $ f x' y'

numBinOp  :: HasCallStack
          => (forall a. (Num a) => a -> a -> a)
          -> String -> Slaw -> Slaw -> Slaw
numBinOp f op x y = numOp f (slawToArg op x) (slawToArg op y)

numUnOp   :: HasCallStack
          => (forall a. (Num a) => a -> a)
          -> String -> Slaw -> Slaw
numUnOp f op x = numOp (curry (f . fst)) x' x'
  where x' = slawToArg op x

fracBinOp :: HasCallStack
          => (forall a. (Fractional a) => a -> a -> a)
          -> String -> Slaw -> Slaw -> Slaw
fracBinOp f op x y = fracOp f (slawToArg op x) (slawToArg op y)

fracUnOp  :: HasCallStack
          => (forall a. (Fractional a) => a -> a)
          -> String -> Slaw -> Slaw
fracUnOp f op x = fracOp (curry (f . fst)) x' x'
  where x' = slawToArg op x

-- See doc/template.txt for more information about template files.

{-# LANGUAGE ScopedTypeVariables        #-}

module Data.Slaw.Internal.Nameable
  ( Nameable(..)
  ) where

-- import Control.DeepSeq
-- import Control.Exception
import qualified Data.ByteString          as B
import qualified Data.ByteString.Lazy     as L
import qualified Data.ByteString.Short    as SBS
-- import Data.Char
import Data.Complex
-- import Data.Default.Class
-- import Data.Either
-- import Data.Hashable
import qualified Data.HashMap.Strict      as HM
import Data.Int
import qualified Data.IntMap.Strict       as IM
import Data.List
import Data.Ratio
import qualified Data.Map.Strict          as M
-- import Data.String
import qualified Data.Text                as T
import qualified Data.Text.Lazy           as LT
import qualified Data.Vector.Storable     as S
import Data.Word
import Foreign.C.Types
import Foreign.Ptr
-- import GHC.Generics (Generic)
-- import GHC.Stack
import Numeric.Half
import Numeric.Natural
-- import System.IO.Unsafe (unsafePerformIO)
-- import Text.Read

import Data.Slaw.Internal.SlawType
import Data.Slaw.Internal.VectorTypes

class Nameable a where
  typeName :: a -> String

typeName' :: Nameable a => a -> String
typeName' x =
  let tn = typeName x
  in if ' ' `elem` tn
     then '(' : tn ++ ")"
     else tn

mkTupleName :: [String] -> String
mkTupleName names = "(" ++ intercalate ", " names ++ ")"

              -- Nameable instances for some basic types --

instance Nameable T.Text where
  typeName _ = "Text"

instance Nameable LT.Text where
  typeName _ = "lazy Text"

instance Nameable B.ByteString where
  typeName _ = "ByteString"

instance Nameable L.ByteString where
  typeName _ = "lazy ByteString"

instance Nameable SBS.ShortByteString where
  typeName _ = "ShortByteString"

--FORSTR (), Bool, Slaw, Char, Integer, Natural
instance Nameable STR where
  typeName _ = "STR"

--END

                  -- Nameable instances for FFI types --

--FORSTR CChar, CSChar,   CUChar,     CWchar
instance Nameable STR where
  typeName _ = "STR"

--FORSTR CBool, CPtrdiff, CSigAtomic, CSize
instance Nameable STR where
  typeName _ = "STR"

--FORSTR CShort,  CInt,  CLong,  CLLong,  CIntMax,  CIntPtr,  IntPtr
instance Nameable STR where
  typeName _ = "STR"

--FORSTR CUShort, CUInt, CULong, CULLong, CUIntMax, CUIntPtr, WordPtr
instance Nameable STR where
  typeName _ = "STR"

--END

                -- Nameable instances for numeric types --

--FOR sizedInt, nativeInt, floating
instance Nameable TYPE where
  typeName _ = "TYPE"

--FOR vectors
instance Nameable a => Nameable (TYPE a) where
  typeName _ = "TYPE " ++ typeName' (undefined :: a)

--END

           -- Nameable instances for various compound types --

instance Nameable a => Nameable [a] where
  typeName _ =
    let tn = typeName (undefined :: a)
    in if tn == "Char"
       then "String"
       else "[" ++ tn ++ "]"

instance Nameable a => Nameable (Maybe a) where
  typeName _ = "Maybe " ++ typeName' (undefined :: a)

instance (Nameable a, Nameable b) => Nameable (Either a b) where
  typeName _ = concat [ "Either "
                      , typeName' (undefined :: a)
                      , " "
                      , typeName' (undefined :: b)
                      ]

instance Nameable a => Nameable (S.Vector a) where
  typeName _ = "Vector " ++ typeName' (undefined :: a)

instance Nameable a => Nameable (Ratio a) where
  typeName _ =
    let tn = typeName' (undefined :: a)
    in if tn == "Integer"
       then "Rational"
       else "Ratio " ++ tn

instance Nameable a => Nameable (Complex a) where
  typeName _ = "Complex " ++ typeName' (undefined :: a)

                    -- Nameable instances for maps --

instance (Nameable a, Nameable b) => Nameable (M.Map a b) where
  typeName _ = concat [ "Map "
                      , typeName' (undefined :: a)
                      , " "
                      , typeName' (undefined :: b)
                      ]

instance (Nameable a, Nameable b) => Nameable (HM.HashMap a b) where
  typeName _ = concat [ "HashMap "
                      , typeName' (undefined :: a)
                      , " "
                      , typeName' (undefined :: b)
                      ]

instance (Nameable b) => Nameable (IM.IntMap b) where
  typeName _ = concat [ "IntMap "
                      , typeName' (undefined :: b)
                      ]

                -- Nameable instances for tuples (2-8) --

instance (Nameable a, Nameable b) => Nameable (a, b) where
  typeName _ = mkTupleName [ typeName (undefined :: a)
                           , typeName (undefined :: b)
                           ]

instance ( Nameable a
         , Nameable b
         , Nameable c
         ) => Nameable (a, b, c) where
  typeName _ = mkTupleName [ typeName (undefined :: a)
                           , typeName (undefined :: b)
                           , typeName (undefined :: c)
                           ]

instance ( Nameable a
         , Nameable b
         , Nameable c
         , Nameable d
         ) => Nameable (a, b, c, d) where
  typeName _ = mkTupleName [ typeName (undefined :: a)
                           , typeName (undefined :: b)
                           , typeName (undefined :: c)
                           , typeName (undefined :: d)
                           ]

instance ( Nameable a
         , Nameable b
         , Nameable c
         , Nameable d
         , Nameable e
         ) => Nameable (a, b, c, d, e) where
  typeName _ = mkTupleName [ typeName (undefined :: a)
                           , typeName (undefined :: b)
                           , typeName (undefined :: c)
                           , typeName (undefined :: d)
                           , typeName (undefined :: e)
                           ]

instance ( Nameable a
         , Nameable b
         , Nameable c
         , Nameable d
         , Nameable e
         , Nameable f
         ) => Nameable (a, b, c, d, e, f) where
  typeName _ = mkTupleName [ typeName (undefined :: a)
                           , typeName (undefined :: b)
                           , typeName (undefined :: c)
                           , typeName (undefined :: d)
                           , typeName (undefined :: e)
                           , typeName (undefined :: f)
                           ]

instance ( Nameable a
         , Nameable b
         , Nameable c
         , Nameable d
         , Nameable e
         , Nameable f
         , Nameable g
         ) => Nameable (a, b, c, d, e, f, g) where
  typeName _ = mkTupleName [ typeName (undefined :: a)
                           , typeName (undefined :: b)
                           , typeName (undefined :: c)
                           , typeName (undefined :: d)
                           , typeName (undefined :: e)
                           , typeName (undefined :: f)
                           , typeName (undefined :: g)
                           ]

instance ( Nameable a
         , Nameable b
         , Nameable c
         , Nameable d
         , Nameable e
         , Nameable f
         , Nameable g
         , Nameable h
         ) => Nameable (a, b, c, d, e, f, g, h) where
  typeName _ = mkTupleName [ typeName (undefined :: a)
                           , typeName (undefined :: b)
                           , typeName (undefined :: c)
                           , typeName (undefined :: d)
                           , typeName (undefined :: e)
                           , typeName (undefined :: f)
                           , typeName (undefined :: g)
                           , typeName (undefined :: h)
                           ]

-- See doc/template.txt for more information about template files.

{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TypeSynonymInstances       #-}

module Data.Slaw.Internal.SlawConvert
  ( FromSlaw(..)
  , ToSlaw(..)
  , š
  , ŝ
  , ŝm
  , ŝes
  , ŝee
  , (?:)
  , handleOthers
  , Protein(..)
  ) where

import Control.DeepSeq
import Control.Exception
import Data.Bits
import qualified Data.ByteString          as B
import qualified Data.ByteString.Lazy     as L
import qualified Data.ByteString.Short    as SBS
import Data.Char
import Data.Complex
import Data.Default.Class
import Data.Either
import Data.Hashable
import qualified Data.HashMap.Strict      as HM
import Data.Int
import qualified Data.IntMap.Strict       as IM
import Data.List
import Data.Ratio
import qualified Data.Map.Strict          as M
import Data.String
import qualified Data.Text                as T
import qualified Data.Text.Lazy           as LT
import qualified Data.Vector.Storable     as S
import Data.Word
import Foreign.Storable
import GHC.Generics (Generic)
import GHC.Stack
import Numeric.Half
import Numeric.Natural
-- import System.IO.Unsafe (unsafePerformIO)
import Text.Read

import Data.Slaw.Internal.Exception
import Data.Slaw.Internal.Nameable
import Data.Slaw.Internal.NativeInt
import Data.Slaw.Internal.NumericConvert
import Data.Slaw.Internal.NumericTypes
import Data.Slaw.Internal.SlawEncode
import Data.Slaw.Internal.SlawType
import Data.Slaw.Internal.String
import Data.Slaw.Internal.Util

---- FromSlaw and ToSlaw classes

class Nameable a => FromSlaw a where
  fromSlaw :: Slaw -> Either PlasmaException a

  listFromSlaw :: Slaw -> Either PlasmaException [a]
  listFromSlaw = defaultListFromSlaw

class ToSlaw a where
  toSlaw :: a -> Slaw

  listToSlaw :: [a] -> Slaw
  listToSlaw = defaultListToSlaw

---- shorthand functions for converting to/from slaw

-- "to slaw" because arrow points towards "s"
{-# INLINE š #-}
š :: ToSlaw a => a -> Slaw
š = toSlaw

-- "from slaw" because arrow points away from "s"
{-# INLINABLE ŝ #-}
ŝ :: (HasCallStack, FromSlaw a) => Slaw -> a
ŝ s = case fromSlaw s of
        Left exc ->
          throw $ exc { peCallstack = Just callStack }
        Right x  -> x

-- "from slaw, maybe"
{-# INLINABLE ŝm #-}
ŝm :: FromSlaw a => Slaw -> Maybe a
ŝm s = case fromSlaw s of
         Left  _ -> Nothing
         Right x -> Just x

-- "from slaw, either string"
{-# INLINABLE ŝes #-}
ŝes :: FromSlaw a => Slaw -> Either String a
ŝes s = case fromSlaw s of
          Left exc -> Left $ displayPlasmaException False exc
          Right x  -> Right x

-- "from slaw, either exception"
{-# INLINE ŝee #-}
ŝee :: (HasCallStack, FromSlaw a) => Slaw -> Either PlasmaException a
ŝee = mapLeft f . fromSlaw
  where cs  = Just callStack
        f e = e { peCallstack = cs }

-- from slaw, with default value
{-# INLINABLE (?:) #-}
(?:) :: FromSlaw a => Slaw -> a -> a
s ?: dflt = case fromSlaw s of
              Left  _ -> dflt
              Right x -> x

---- helper functions for implementing ToSlaw/FromSlaw

handleOthers :: forall a. (Nameable a)
             => Slaw
             -> Either PlasmaException a
handleOthers = handleOthers' (typeName (undefined :: a))

handleOthers' :: String -> Slaw -> Either PlasmaException a
handleOthers' _ (SlawError msg loc)
  | typeMismatchPfx `isPrefixOf` msg = Left $ typeMismatch' msg loc
  | rangeErrorPfx   `isPrefixOf` msg = Left $ typeMismatch' msg loc
  | otherwise                        = Left $ corruptSlaw   msg loc
handleOthers' toType slaw = Left $ typeMismatch msg
  where msg = slaw `cantCoerceSlaw` toType

cantCoerceSlaw :: Slaw -> String -> String
cantCoerceSlaw slaw other = describeSlaw slaw `cantCoerce` other

addErrCtx :: forall a. (Nameable a)
          => Slaw
          -> Either PlasmaException a
          -> Either PlasmaException a
addErrCtx s = mapLeft f
  where f err = msg `because1` [err]
        msg = s `cantCoerceSlaw` typeName (undefined :: a)

addErrCtxStr :: String
             -> String
             -> Either PlasmaException a
             -> Either PlasmaException a
addErrCtxStr fromType toType = mapLeft f
  where f err = msg `because1` [err]
        msg = fromType `cantCoerce` toType

defaultListToSlaw :: ToSlaw a => [a] -> Slaw
defaultListToSlaw = SlawList . map toSlaw

defaultListFromSlaw :: forall a. (FromSlaw a)
                    => Slaw
                    -> Either PlasmaException [a]
defaultListFromSlaw SlawNil       = Right []
defaultListFromSlaw s@(SlawList ss) =
  let msg = s `cantCoerceSlaw` typeName (undefined :: a)
  in fromSlawList msg ss
defaultListFromSlaw s@(SlawMap pairs) =
  let msg    = s `cantCoerceSlaw` typeName (undefined :: a)
      conses = map (uncurry SlawCons) pairs
  in fromSlawList msg conses
defaultListFromSlaw s@(SlawCons car cdr) =
  let msg = s `cantCoerceSlaw` typeName (undefined :: a)
  in fromSlawList msg [car, cdr]
defaultListFromSlaw s@(SlawNumeric nf nd) =
  let msg = s `cantCoerceSlaw` typeName (undefined :: a)
  in case numericArrayToList nf nd of
       Nothing         -> Left $ typeMismatch msg
       Just (nf', nds) -> fromSlawList msg $ map (SlawNumeric nf') nds
defaultListFromSlaw s             = handleOthers s

fromSlawList :: FromSlaw a
             => String
             -> [Slaw]
             -> Either PlasmaException [a]
fromSlawList msg ss =
  case partitionEithers (map fromSlaw ss) of
    ([],      []) -> Right []
    ((err:_), []) -> msg `because` [err]
    (_,       xs) -> Right xs

numericArrayToList :: NumericFormat
                   -> NumericData
                   -> Maybe (NumericFormat, [NumericData])
numericArrayToList nf nd = if isArray then Just (nf', nds) else Nothing
  where
    isArray  = nfArray nf
    nf'      = nf { nfArray = False }
    stepSize = computeBsize nf 1
    nds      = chunkNumericData stepSize nd

chunkNumericData :: Int -> NumericData -> [NumericData]
--FOR sizedInt, floating
chunkNumericData n (NumNAMEXX v) = map NumNAMEXX $ chunkArray n v
--END

chunkArray :: Storable a
           => Int
           -> S.Vector a
           -> [S.Vector a]
chunkArray stepSize v = v0 : chunkArray stepSize vRest
  where (v0, vRest) = S.splitAt stepSize v

slawFromString :: TextClass a => a -> Slaw
slawFromString = SlawString . toUtf8

slawToString :: (FromSlaw a, TextClass a)
             => Slaw
             -> Either PlasmaException a
slawToString (SlawBool b)   = (Right . fromString . map toLower . show) b
slawToString SlawNil        = (Right . fromText) "nil"
slawToString (SlawString u) = (Right . fromUtf8) u
slawToString s@(SlawNumeric _ nd) = numToStr     s nd
slawToString s                    = handleOthers s

numToStr :: (FromSlaw a, TextClass a)
         => Slaw
         -> NumericData
         -> Either PlasmaException a
--FOR sizedInt, floating
numToStr s (NumNAMEXX v) = numToStr1 s v
--END

numToStr1 :: (FromSlaw a, TextClass a, Storable b, Show b)
          => Slaw
          -> S.Vector b
          -> Either PlasmaException a
numToStr1 s v
  | S.length v == 1 = (Right . fromString . show . S.head) v
  | otherwise       = handleOthers s

numToInteger :: NumericData -> Maybe Integer
--FOR sizedInt
numToInteger (NumNAMEXX v) = numToInteger1 v
--FOR floating
numToInteger (NumNAMEXX _) = Nothing
--END

numToInteger1 :: (Storable a, Integral a) => S.Vector a -> Maybe Integer
numToInteger1 v
  | S.length v == 1 = (Just . toInteger . S.head) v
  | otherwise       = Nothing

nfScalar :: NumericFormat
nfScalar = NumericFormat
  { nfArray   = False
  , nfComplex = False
  , nfVector  = VtScalar
  }

nfScalarArray :: NumericFormat
nfScalarArray = nfScalar { nfArray = True }

slawFromByteString :: ByteStringClass a => a -> Slaw
slawFromByteString x = SlawNumeric nfScalarArray nd
  where bs = toByteString x
        nd = restoreNumeric bo TypUnt8 bs
        -- Byte order should not matter, since we are using
        -- a single-byte type (unt8)
        bo = BigEndian

slawToByteString :: (FromSlaw a, ByteStringClass a)
                 => Slaw
                 -> Either PlasmaException a
slawToByteString (SlawProtein _ _ rude) = Right $ fromLazyByteString rude
slawToByteString (SlawString  lbs     ) = Right $ fromLazyByteString lbs
slawToByteString (SlawNumeric nf nd   )
  | nf == nfScalarArray && nt `elem` [TypInt8, TypUnt8] =
      Right $ fromByteString bs
  where (nt, bs) = extractNumeric bo nd
        -- Again, byte order does not matter for int8/unt8
        bo       = BigEndian
slawToByteString s = handleOthers s

mkTupleName :: [String] -> String
mkTupleName names = "(" ++ intercalate ", " names ++ ")"

pairFromSlaw :: forall a b. (FromSlaw a, FromSlaw b)
             => Slaw
             -> (Slaw, Slaw)
             -> Either PlasmaException (a, b)
pairFromSlaw s pair = addErrCtx s (pairFromSlaw' pair)

pairFromSlaw' :: (FromSlaw a, FromSlaw b)
              => (Slaw, Slaw)
              -> Either PlasmaException (a, b)
pairFromSlaw' (x, y) = do
  x' <- fromSlaw x
  y' <- fromSlaw y
  return (x', y')

tripleFromSlaw :: forall a b c. ( FromSlaw a
                                , FromSlaw b
                                , FromSlaw c
                                )
               => Slaw
               -> (Slaw, Slaw, Slaw)
               -> Either PlasmaException (a, b, c)
tripleFromSlaw s triple =
  addErrCtx s $ tripleFromSlaw' triple

tripleFromSlaw' :: ( FromSlaw a
                   , FromSlaw b
                   , FromSlaw c
                   )
                => (Slaw, Slaw, Slaw)
                -> Either PlasmaException (a, b, c)
tripleFromSlaw' (x, y, z) = do
  x' <- fromSlaw x
  y' <- fromSlaw y
  z' <- fromSlaw z
  return (x', y', z')

quadrupleFromSlaw :: forall a b c d. ( FromSlaw a
                                     , FromSlaw b
                                     , FromSlaw c
                                     , FromSlaw d
                                     )
                  => Slaw
                  -> (Slaw, Slaw, Slaw, Slaw)
                  -> Either PlasmaException (a, b, c, d)
quadrupleFromSlaw s quadruple =
  addErrCtx s $ quadrupleFromSlaw' quadruple

quadrupleFromSlaw' :: ( FromSlaw a
                      , FromSlaw b
                      , FromSlaw c
                      , FromSlaw d
                      )
                   => (Slaw, Slaw, Slaw, Slaw)
                   -> Either PlasmaException (a, b, c, d)
quadrupleFromSlaw' (w, x, y, z) = do
  w' <- fromSlaw w
  x' <- fromSlaw x
  y' <- fromSlaw y
  z' <- fromSlaw z
  return (w', x', y', z')

quintupleFromSlaw :: forall a b c d e. ( FromSlaw a
                                       , FromSlaw b
                                       , FromSlaw c
                                       , FromSlaw d
                                       , FromSlaw e
                                       )
                  => Slaw
                  -> (Slaw, Slaw, Slaw, Slaw, Slaw)
                  -> Either PlasmaException (a, b, c, d, e)
quintupleFromSlaw s quintuple =
  addErrCtx s $ quintupleFromSlaw' quintuple

quintupleFromSlaw' :: ( FromSlaw a
                      , FromSlaw b
                      , FromSlaw c
                      , FromSlaw d
                      , FromSlaw e
                      )
                   => (Slaw, Slaw, Slaw, Slaw, Slaw)
                   -> Either PlasmaException (a, b, c, d, e)
quintupleFromSlaw' (v, w, x, y, z) = do
  v' <- fromSlaw v
  w' <- fromSlaw w
  x' <- fromSlaw x
  y' <- fromSlaw y
  z' <- fromSlaw z
  return (v', w', x', y', z')

sextupleFromSlaw :: forall a b c d e f. ( FromSlaw a
                                        , FromSlaw b
                                        , FromSlaw c
                                        , FromSlaw d
                                        , FromSlaw e
                                        , FromSlaw f
                                        )
                 => Slaw
                 -> (Slaw, Slaw, Slaw, Slaw, Slaw, Slaw)
                 -> Either PlasmaException (a, b, c, d, e, f)
sextupleFromSlaw s sextuple =
  addErrCtx s $ sextupleFromSlaw' sextuple

sextupleFromSlaw' :: ( FromSlaw a
                     , FromSlaw b
                     , FromSlaw c
                     , FromSlaw d
                     , FromSlaw e
                     , FromSlaw f
                     )
                  => (Slaw, Slaw, Slaw, Slaw, Slaw, Slaw)
                  -> Either PlasmaException (a, b, c, d, e, f)
sextupleFromSlaw' (u, v, w, x, y, z) = do
  u' <- fromSlaw u
  v' <- fromSlaw v
  w' <- fromSlaw w
  x' <- fromSlaw x
  y' <- fromSlaw y
  z' <- fromSlaw z
  return (u', v', w', x', y', z')

septupleFromSlaw :: forall a b c d e f g. ( FromSlaw a
                                          , FromSlaw b
                                          , FromSlaw c
                                          , FromSlaw d
                                          , FromSlaw e
                                          , FromSlaw f
                                          , FromSlaw g
                                          )
                 => Slaw
                 -> (Slaw, Slaw, Slaw, Slaw, Slaw, Slaw, Slaw)
                 -> Either PlasmaException (a, b, c, d, e, f, g)
septupleFromSlaw s septuple =
  addErrCtx s $ septupleFromSlaw' septuple

septupleFromSlaw' :: ( FromSlaw a
                     , FromSlaw b
                     , FromSlaw c
                     , FromSlaw d
                     , FromSlaw e
                     , FromSlaw f
                     , FromSlaw g
                     )
                  => (Slaw, Slaw, Slaw, Slaw, Slaw, Slaw, Slaw)
                  -> Either PlasmaException (a, b, c, d, e, f, g)
septupleFromSlaw' (t, u, v, w, x, y, z) = do
  t' <- fromSlaw t
  u' <- fromSlaw u
  v' <- fromSlaw v
  w' <- fromSlaw w
  x' <- fromSlaw x
  y' <- fromSlaw y
  z' <- fromSlaw z
  return (t', u', v', w', x', y', z')

octupleFromSlaw :: forall a b c d e f g h. ( FromSlaw a
                                           , FromSlaw b
                                           , FromSlaw c
                                           , FromSlaw d
                                           , FromSlaw e
                                           , FromSlaw f
                                           , FromSlaw g
                                           , FromSlaw h
                                           )
                => Slaw
                -> (Slaw, Slaw, Slaw, Slaw, Slaw, Slaw, Slaw, Slaw)
                -> Either PlasmaException (a, b, c, d, e, f, g, h)
octupleFromSlaw s octuple =
  addErrCtx s $ octupleFromSlaw' octuple

octupleFromSlaw' :: ( FromSlaw a
                    , FromSlaw b
                    , FromSlaw c
                    , FromSlaw d
                    , FromSlaw e
                    , FromSlaw f
                    , FromSlaw g
                    , FromSlaw h
                    )
                 => (Slaw, Slaw, Slaw, Slaw, Slaw, Slaw, Slaw, Slaw)
                 -> Either PlasmaException (a, b, c, d, e, f, g, h)
octupleFromSlaw' (r, t, u, v, w, x, y, z) = do
  r' <- fromSlaw r
  t' <- fromSlaw t
  u' <- fromSlaw u
  v' <- fromSlaw v
  w' <- fromSlaw w
  x' <- fromSlaw x
  y' <- fromSlaw y
  z' <- fromSlaw z
  return (r', t', u', v', w', x', y', z')

slawFromMap :: (ToSlaw a, ToSlaw b) => [(a, b)] -> Slaw
slawFromMap = SlawMap . map f
  where f (x, y) = (toSlaw x, toSlaw y)

slawToMap :: (FromSlaw a, FromSlaw b, FromSlaw z)
          => Slaw
          -> z
          -> Either PlasmaException [(a, b)]
slawToMap s@(SlawMap pairs                         ) = mapFromSlaw s pairs
slawToMap s@(SlawProtein _ (Just (SlawMap pairs)) _) = mapFromSlaw s pairs
slawToMap s@(SlawList ss                           ) = mapFromSlaw s pairs
  where pairs = zip (map toSlaw [(0::Integer)..]) ss
slawToMap s = const (handleOthers s)

mapFromSlaw :: (FromSlaw a, FromSlaw b, FromSlaw z)
            => Slaw
            -> [(Slaw, Slaw)]
            -> z
            -> Either PlasmaException [(a, b)]
mapFromSlaw s pairs dummy =
  let msg = s `cantCoerceSlaw` typeName dummy
  in case partitionEithers (map mfs1 pairs) of
       ([],      []) -> Right []
       ((err:_), []) -> msg `because` [err]
       (_,       xs) -> Right xs

mfs1 :: forall a b. (FromSlaw a, FromSlaw b)
     => (Slaw, Slaw)
     -> Either PlasmaException (a, b)
mfs1 pair@(x, y) = addErrCtxStr fromType toType (pairFromSlaw' pair)
  where fromType = mkTupleName $ map describeSlaw [x, y]
        toType   = typeName (undefined :: (a, b))

proteinFromSlaw :: Slaw
                -> (Maybe Slaw, Maybe Slaw, L.ByteString)
                -> Either PlasmaException Protein
proteinFromSlaw s (des, ing, rude) =
  let des' = des ?> SlawList []
      ing' = ing ?> SlawMap  []
  in case pairFromSlaw' (des', ing') of
       Left err ->
         let msg = s `cantCoerceSlaw` typeName (undefined :: Protein)
         in msg `because` [err]
       Right (des2, ing2) -> Right $ Protein des2 ing2 rude

integerFromSlaw :: String
                -> Slaw
                -> Either PlasmaException Integer
integerFromSlaw toType s@(SlawNumeric _ nd) =
  case numToInteger nd of
    Nothing -> handleOthers' toType s
    Just n  -> Right n
integerFromSlaw toType (SlawString utf8) =
  let str = fromUtf8 utf8
  in case readMaybe str of
       Just n  -> Right n
       Nothing -> Left $ typeMismatch $ show str `cantCoerce` toType
integerFromSlaw toType s = handleOthers' toType s

integralFromSlaw :: forall a. (Nameable a, Integral a, Bits a)
                 => Slaw
                 -> Either PlasmaException a
integralFromSlaw s = do
  let tn     = typeName (undefined :: a)
  n <- integerFromSlaw tn s
  let desc   = describeSlaw s
  integralFromInteger desc n

integralFromInteger :: forall a. (Nameable a, Integral a, Bits a)
                    => String
                    -> Integer
                    -> Either PlasmaException a
integralFromInteger desc n = do
  let tn     = typeName (undefined :: a)
      nParen = '(' : show n ++ ")"
      rErr   = rangeError desc nParen tn
  case safeIntegralFromInteger n of
    Left (lo, mhi) -> Left $ rErr (show lo) (fmap show mhi ?> "")
    Right x        -> return x

integralPairFromSlaw :: forall a. (Nameable a, Integral a, Bits a)
                     => (Slaw, Slaw)
                     -> Either PlasmaException (a, a)
integralPairFromSlaw (x, y) = do
  x' <- integralFromSlaw x
  y' <- integralFromSlaw y
  return (x', y')

numericVectorFromSlaw :: NumericClass a
                      => Slaw
                      -> Either PlasmaException (S.Vector a)
numericVectorFromSlaw s@(SlawNumeric nf nd) =
  addErrCtx s $ ndToNumeric (nf, nd)
numericVectorFromSlaw s = handleOthers s

numericVectorToSlaw :: NumericClass a
                    => S.Vector a
                    -> Slaw
numericVectorToSlaw v = SlawNumeric nf' nd
  where (nf, nd) = numericToNd v
        nf'      = nf { nfArray = True }

numericSingletonFromSlaw :: NumericClass a
                         => Slaw
                         -> Either PlasmaException a
numericSingletonFromSlaw s@(SlawNumeric nf nd) = addErrCtx s $ do
  v <- ndToNumeric (nf, nd)
  case S.length v of
    1 -> return $ S.head v
    n -> Left $ typeMismatch $ concat [ "Got array of length "
                                      , show n
                                      , " but expected singleton"
                                      ]
numericSingletonFromSlaw s = handleOthers s

numericSingletonToSlaw :: NumericClass a
                       => a
                       -> Slaw
numericSingletonToSlaw x = SlawNumeric nf' nd
  where (nf, nd) = numericToNd v
        nf'      = nf { nfArray = True }
        v        = S.singleton x

ndToRat :: forall a. (Nameable a, Integral a, Bits a)
        => NumericFormat
        -> NumericData
        -> Either PlasmaException (Ratio a)
ndToRat nf nd = do
  let desc   = describeNumeric nf nd
      descNd = describeNumericData nd
      toType = typeName (undefined :: Ratio a)
      ctx    = addErrCtxStr desc toType
      iFi    = integralFromInteger descNd
  case numToList nd of
    [ElemInt num, ElemInt den] -> ctx $ do
      num' <- iFi num
      den' <- iFi den
      makeRat num' den'
    [ElemInt num]              -> ctx $ do
      num' <- iFi num
      makeRat num' 1
--FOR floating
    [ElemTYPEXX x]             -> return (realToFrac x)
--END
    _                          ->
      Left $ typeMismatch $ desc `cantCoerce` toType

makeRat :: Integral a => a -> a -> Either PlasmaException (Ratio a)
makeRat num den
  | den == 0  = Left  $ rangeError0 "denominator is zero"
  | otherwise = Right $ num % den

---- types

data Protein = Protein
  { pDescrips :: [T.Text]
  , pIngests  :: M.Map T.Text Slaw
  , pRudeData :: L.ByteString
  } deriving (Eq, Ord, Show, Generic, NFData, Hashable)

instance Default Protein where
  def = Protein [] M.empty L.empty

instance Nameable Protein where
  typeName _ = "Protein"

---- instances

                   -- instances for Slaw (identity) --

instance FromSlaw Slaw where
  fromSlaw = Right

instance ToSlaw Slaw where
  toSlaw = id

                        -- instances for lists --

instance FromSlaw a => FromSlaw [a] where
  fromSlaw = listFromSlaw

instance ToSlaw a => ToSlaw [a] where
  toSlaw = listToSlaw

                         -- instances for Bool --

instance FromSlaw Bool where
  fromSlaw (SlawBool b)     = Right b
  fromSlaw SlawNil          = Right False
  fromSlaw (SlawString lbs)
    | lbs ==~ "false"       = Right False
    | lbs ==~ "true"        = Right True
  fromSlaw s                = handleOthers s

instance ToSlaw Bool where
  toSlaw = SlawBool

                          -- instances for () --

instance FromSlaw () where
  fromSlaw SlawNil = Right ()
  fromSlaw s       = handleOthers s

instance ToSlaw () where
  toSlaw _ = SlawNil

                         -- instances for Text --

instance FromSlaw T.Text where
  fromSlaw = slawToString

instance ToSlaw T.Text where
  toSlaw = slawFromString

instance FromSlaw LT.Text where
  fromSlaw = slawToString

instance ToSlaw LT.Text where
  toSlaw = slawFromString

                     -- instances for Char/String --

instance FromSlaw Char where
  fromSlaw s@(SlawNumeric _ nd) =
    case numToInteger nd of
      Nothing -> handleOthers s
      Just n
        | n >= 0 && n <= (toInteger . ord) (maxBound :: Char) ->
            (Right . chr . fromInteger) n
        | otherwise -> Left $ typeMismatch $ show n `cantCoerce` "Char"
  fromSlaw s = handleOthers s

  listFromSlaw = slawToString

instance ToSlaw Char where
  toSlaw c = SlawNumeric nfScalar nd
    where nd = (NumUnt32 . S.singleton . fromIntegral . ord) c

  listToSlaw = slawFromString

                     -- instances for bytestrings --

instance FromSlaw B.ByteString where
  fromSlaw = slawToByteString

instance ToSlaw B.ByteString where
  toSlaw = slawFromByteString

instance FromSlaw L.ByteString where
  fromSlaw = slawToByteString

instance ToSlaw L.ByteString where
  toSlaw = slawFromByteString

instance FromSlaw SBS.ShortByteString where
  fromSlaw = slawToByteString

instance ToSlaw SBS.ShortByteString where
  toSlaw = slawFromByteString

                     -- instances for tuples (2-8) --

instance (FromSlaw a, FromSlaw b) => FromSlaw (a, b) where
  fromSlaw s@(SlawProtein des ing _) = pairFromSlaw s ( des ?> SlawList []
                                                      , ing ?> SlawMap  []
                                                      )
  fromSlaw s@(SlawCons    car cdr  ) = pairFromSlaw s (car, cdr)
  fromSlaw s@(SlawList    [x, y]   ) = pairFromSlaw s (x,   y  )
  fromSlaw s@(SlawNumeric nf  nd   ) =
    case numericArrayToList nf nd of
      Just (nf', [x, y]) -> pairFromSlaw s ( SlawNumeric nf' x
                                           , SlawNumeric nf' y
                                           )
      _                  -> handleOthers s
  fromSlaw s              = handleOthers s

instance (ToSlaw a, ToSlaw b) => ToSlaw (a, b) where
  toSlaw (car, cdr) = SlawCons (toSlaw car) (toSlaw cdr)

instance ( FromSlaw a
         , FromSlaw b
         , FromSlaw c
         ) => FromSlaw (a, b, c) where
  fromSlaw s@(SlawList [x, y, z]) =
    tripleFromSlaw s (x, y, z)
  fromSlaw s@(SlawNumeric nf nd) =
    case numericArrayToList nf nd of
      Just (nf', [x, y, z]) ->
        tripleFromSlaw s ( SlawNumeric nf' x
                         , SlawNumeric nf' y
                         , SlawNumeric nf' z
                         )
      _                     -> handleOthers s
  fromSlaw s = handleOthers s

instance ( ToSlaw a
         , ToSlaw b
         , ToSlaw c
         ) => ToSlaw (a, b, c) where
  toSlaw (x, y, z) =
    SlawList [ toSlaw x
             , toSlaw y
             , toSlaw z
             ]

instance ( FromSlaw a
         , FromSlaw b
         , FromSlaw c
         , FromSlaw d
         ) => FromSlaw (a, b, c, d) where
  fromSlaw s@(SlawList [w, x, y, z]) =
    quadrupleFromSlaw s (w, x, y, z)
  fromSlaw s@(SlawNumeric nf nd) =
    case numericArrayToList nf nd of
      Just (nf', [w, x, y, z]) ->
        quadrupleFromSlaw s ( SlawNumeric nf' w
                            , SlawNumeric nf' x
                            , SlawNumeric nf' y
                            , SlawNumeric nf' z
                            )
      _                        -> handleOthers s
  fromSlaw s = handleOthers s

instance ( ToSlaw a
         , ToSlaw b
         , ToSlaw c
         , ToSlaw d
         ) => ToSlaw (a, b, c, d) where
  toSlaw (w, x, y, z) =
    SlawList [ toSlaw w
             , toSlaw x
             , toSlaw y
             , toSlaw z
             ]

instance ( FromSlaw a
         , FromSlaw b
         , FromSlaw c
         , FromSlaw d
         , FromSlaw e
         ) => FromSlaw (a, b, c, d, e) where
  fromSlaw s@(SlawList [v, w, x, y, z]) =
    quintupleFromSlaw s (v, w, x, y, z)
  fromSlaw s@(SlawNumeric nf nd) =
    case numericArrayToList nf nd of
      Just (nf', [v, w, x, y, z]) ->
        quintupleFromSlaw s ( SlawNumeric nf' v
                            , SlawNumeric nf' w
                            , SlawNumeric nf' x
                            , SlawNumeric nf' y
                            , SlawNumeric nf' z
                            )
      _                           -> handleOthers s
  fromSlaw s = handleOthers s

instance ( ToSlaw a
         , ToSlaw b
         , ToSlaw c
         , ToSlaw d
         , ToSlaw e
         ) => ToSlaw (a, b, c, d, e) where
  toSlaw (v, w, x, y, z) =
    SlawList [ toSlaw v
             , toSlaw w
             , toSlaw x
             , toSlaw y
             , toSlaw z
             ]

instance ( FromSlaw a
         , FromSlaw b
         , FromSlaw c
         , FromSlaw d
         , FromSlaw e
         , FromSlaw f
         ) => FromSlaw (a, b, c, d, e, f) where
  fromSlaw s@(SlawList [u, v, w, x, y, z]) =
    sextupleFromSlaw s (u, v, w, x, y, z)
  fromSlaw s@(SlawNumeric nf nd) =
    case numericArrayToList nf nd of
      Just (nf', [u, v, w, x, y, z]) ->
        sextupleFromSlaw s ( SlawNumeric nf' u
                           , SlawNumeric nf' v
                           , SlawNumeric nf' w
                           , SlawNumeric nf' x
                           , SlawNumeric nf' y
                           , SlawNumeric nf' z
                           )
      _                              -> handleOthers s
  fromSlaw s = handleOthers s

instance ( ToSlaw a
         , ToSlaw b
         , ToSlaw c
         , ToSlaw d
         , ToSlaw e
         , ToSlaw f
         ) => ToSlaw (a, b, c, d, e, f) where
  toSlaw (u, v, w, x, y, z) =
    SlawList [ toSlaw u
             , toSlaw v
             , toSlaw w
             , toSlaw x
             , toSlaw y
             , toSlaw z
             ]

instance ( FromSlaw a
         , FromSlaw b
         , FromSlaw c
         , FromSlaw d
         , FromSlaw e
         , FromSlaw f
         , FromSlaw g
         ) => FromSlaw (a, b, c, d, e, f, g) where
  fromSlaw s@(SlawList [t, u, v, w, x, y, z]) =
    septupleFromSlaw s (t, u, v, w, x, y, z)
  fromSlaw s@(SlawNumeric nf nd) =
    case numericArrayToList nf nd of
      Just (nf', [t, u, v, w, x, y, z]) ->
        septupleFromSlaw s ( SlawNumeric nf' t
                           , SlawNumeric nf' u
                           , SlawNumeric nf' v
                           , SlawNumeric nf' w
                           , SlawNumeric nf' x
                           , SlawNumeric nf' y
                           , SlawNumeric nf' z
                           )
      _                                 -> handleOthers s
  fromSlaw s = handleOthers s

instance ( ToSlaw a
         , ToSlaw b
         , ToSlaw c
         , ToSlaw d
         , ToSlaw e
         , ToSlaw f
         , ToSlaw g
         ) => ToSlaw (a, b, c, d, e, f, g) where
  toSlaw (t, u, v, w, x, y, z) =
    SlawList [ toSlaw t
             , toSlaw u
             , toSlaw v
             , toSlaw w
             , toSlaw x
             , toSlaw y
             , toSlaw z
             ]

instance ( FromSlaw a
         , FromSlaw b
         , FromSlaw c
         , FromSlaw d
         , FromSlaw e
         , FromSlaw f
         , FromSlaw g
         , FromSlaw h
         ) => FromSlaw (a, b, c, d, e, f, g, h) where
  fromSlaw s@(SlawList [r, t, u, v, w, x, y, z]) =
    octupleFromSlaw s (r, t, u, v, w, x, y, z)
  fromSlaw s@(SlawNumeric nf nd) =
    case numericArrayToList nf nd of
      Just (nf', [r, t, u, v, w, x, y, z]) ->
        octupleFromSlaw s ( SlawNumeric nf' r
                          , SlawNumeric nf' t
                          , SlawNumeric nf' u
                          , SlawNumeric nf' v
                          , SlawNumeric nf' w
                          , SlawNumeric nf' x
                          , SlawNumeric nf' y
                          , SlawNumeric nf' z
                          )
      _                                    -> handleOthers s
  fromSlaw s = handleOthers s

instance ( ToSlaw a
         , ToSlaw b
         , ToSlaw c
         , ToSlaw d
         , ToSlaw e
         , ToSlaw f
         , ToSlaw g
         , ToSlaw h
         ) => ToSlaw (a, b, c, d, e, f, g, h) where
  toSlaw (r, t, u, v, w, x, y, z) =
    SlawList [ toSlaw r
             , toSlaw t
             , toSlaw u
             , toSlaw v
             , toSlaw w
             , toSlaw x
             , toSlaw y
             , toSlaw z
             ]

                        -- instances for Either --

instance (FromSlaw a, FromSlaw b) => FromSlaw (Either a b) where
  fromSlaw s =
    case (fromSlaw s, fromSlaw s) of
      (Right x, _      ) -> Right $ Left  x
      (Left  _, Right x) -> Right $ Right x
      (Left e1, Left e2) ->
        let msg = s `cantCoerceSlaw` typeName (undefined :: Either a b)
        in msg `because` [e1, e2]

instance (ToSlaw a, ToSlaw b) => ToSlaw (Either a b) where
  toSlaw (Left x ) = toSlaw x
  toSlaw (Right x) = toSlaw x

                        -- instances for Maybe --

instance FromSlaw a => FromSlaw (Maybe a) where
  fromSlaw SlawNil = Right Nothing
  fromSlaw s = addErrCtx s (fromSlaw s)

instance ToSlaw a => ToSlaw (Maybe a) where
  toSlaw Nothing  = SlawNil
  toSlaw (Just x) = toSlaw x

                         -- instances for maps --

instance (FromSlaw a, FromSlaw b, Ord a) => FromSlaw (M.Map a b) where
  fromSlaw s = mapRight M.fromList $ slawToMap s (M.empty :: M.Map a b)

instance (ToSlaw a, ToSlaw b, Ord a) => ToSlaw (M.Map a b) where
  toSlaw = slawFromMap . M.toList

instance ( FromSlaw a
         , FromSlaw b
         , Hashable a
         ) => FromSlaw (HM.HashMap a b) where
  fromSlaw s =
    mapRight HM.fromList $ slawToMap s (HM.empty :: HM.HashMap a b)

instance (ToSlaw a, ToSlaw b, Ord a) => ToSlaw (HM.HashMap a b) where
  toSlaw = slawFromMap . HM.toList

instance (FromSlaw b) => FromSlaw (IM.IntMap b) where
  fromSlaw s =
    mapRight IM.fromList $ slawToMap s (IM.empty :: IM.IntMap b)

instance (ToSlaw b) => ToSlaw (IM.IntMap b) where
  toSlaw = slawFromMap . IM.toList

                       -- instances for Protein --

instance FromSlaw Protein where
  fromSlaw SlawNil                      = Right def
  fromSlaw s@(SlawProtein des ing rude) =
    proteinFromSlaw s (des, ing, rude)
  fromSlaw s@(SlawMap _)                =
    proteinFromSlaw s (Nothing, Just s, L.empty)
  fromSlaw s@(SlawCons car cdr)         =
    proteinFromSlaw s (Just car, Just cdr, L.empty)
  fromSlaw s                            = handleOthers s

instance ToSlaw Protein where
  toSlaw (Protein des ing rude) =
    let des' = if null   des then Nothing else (Just . toSlaw) des
        ing' = if M.null ing then Nothing else (Just . toSlaw) ing
    in SlawProtein des' ing' rude

                 -- instances for Integer and Natural --

instance FromSlaw Integer where
  fromSlaw = integerFromSlaw "Integer"

instance ToSlaw Integer where
  toSlaw n =
    case integerToNum n of
      Just nd -> SlawNumeric nfScalar nd
      Nothing -> SlawString $ toUtf8 $ show n

instance FromSlaw Natural where
  fromSlaw = integralFromSlaw

instance ToSlaw Natural where
  toSlaw = toSlaw . toInteger

                    -- instances for Ratio/Rational --

instance forall a. ( Nameable a
                   , Integral a
                   , Bits     a
                   ) => FromSlaw (Ratio a) where
  fromSlaw s@(SlawCons car cdr) =
    case integralPairFromSlaw (car, cdr) of
      Left err ->
        let msg = s `cantCoerceSlaw` typeName (undefined :: Ratio a)
        in msg `because` [err]
      Right (num, den) -> addErrCtx s $ makeRat num den
  fromSlaw (SlawNumeric nf nd) = ndToRat nf nd
  fromSlaw s = handleOthers s

instance Integral a => ToSlaw (Ratio a) where
  toSlaw rat = SlawCons (f $ numerator rat) (f $ denominator rat)
    where f  = toSlaw . toInteger

          -- FromSlaw instances for singleton (real) numbers --

--FOR sizedInt, nativeInt

instance FromSlaw TYPEXX where
  fromSlaw = integralFromSlaw

--FOR floating

instance FromSlaw TYPEXX where
  fromSlaw s@(SlawCons _ _) =
    case fromSlaw s of
      Left err ->
        let msg = s `cantCoerceSlaw` "TYPE"
        in msg `because` [err]
      Right rat -> Right $ fromRational rat
  fromSlaw s = numericSingletonFromSlaw s

--END

           -- ToSlaw instances for singleton (real) numbers --

--FOR sizedInt, floating

instance ToSlaw TYPEXX where
  toSlaw = SlawNumeric nfScalar . NumNAMEXX . S.singleton

--FOR nativeInt

instance ToSlaw TYPEXX where
  toSlaw = toSlaw . toNativeTYPE

--END

                  -- instances for Complex singletons --

instance (RealClass a) => FromSlaw (Complex a) where
  fromSlaw = numericSingletonFromSlaw

instance (RealClass a) => ToSlaw (Complex a) where
  toSlaw = numericSingletonToSlaw

            -- instances for (geometric) vectors (V2/V3/V4) --

--FOR vectors

instance (ScalarClass a) => FromSlaw (TYPEXX a) where
  fromSlaw = numericSingletonFromSlaw

instance (ScalarClass a) => ToSlaw (TYPEXX a) where
  toSlaw = numericSingletonToSlaw

--END

          -- instances for Storable Vectors of numeric types --

instance NumericClass a => FromSlaw (S.Vector a) where
  fromSlaw = numericVectorFromSlaw

instance NumericClass a => ToSlaw (S.Vector a) where
  toSlaw   = numericVectorToSlaw

-- See doc/template.txt for more information about template files.

{-# LANGUAGE RankNTypes                 #-}

module Data.Slaw.Internal.Helpers
  ( PlasmaIntegral
  , PlasmaFloat
  , mapNumericData
  , mapNumericData2
  , mapNumericData'
  , mapNumericData2'
  , fromNumericData
  , fromNumericData2
  , toNumericData
  , sliceNumericData
  , lengthNumericData
  ) where

import Control.Arrow (first)
-- import Control.DeepSeq
import Data.Bits
-- import Data.Hashable
import Data.Int
import qualified Data.Vector.Storable as S
import Data.Word
import Foreign.Storable
import Numeric.Half
-- import Text.Printf

import Data.Slaw.Internal.HalfOrphans ()
-- import Data.Slaw.Internal.Nameable
import Data.Slaw.Internal.NumericConvert
import Data.Slaw.Internal.SlawType

                              -- classes --

class ( PlasmaReal a
      , Integral   a
      , Bounded    a
      , Enum       a
      , Bits       a
      ) => PlasmaIntegral a

--FOR sizedInt, nativeInt
instance PlasmaIntegral TYPE
--END

class ( PlasmaReal a
      , RealFloat  a
      ) => PlasmaFloat a

--FOR floating
instance PlasmaFloat TYPE
--END

                           -- mapNumericData --

mapNumericData :: (forall a. (PlasmaReal a) => S.Vector a -> S.Vector a)
               -> NumericData
               -> NumericData
--FOR sizedInt, floating
mapNumericData func (NumNAMEXX v) = NumNAMEXX $ func v
--END

mapNumericData2 :: (forall a. ( PlasmaIntegral a
                              ) => S.Vector a -> S.Vector a)
                -> (forall b. ( PlasmaFloat b
                              ) => S.Vector b -> S.Vector b)
                -> NumericData
                -> NumericData
--FOR sizedInt
mapNumericData2 func _ (NumNAMEXX v) = NumNAMEXX $ func v
--FOR floating
mapNumericData2 _ func (NumNAMEXX v) = NumNAMEXX $ func v
--END

                          -- mapNumericData' --

mapNumericData' :: (forall a. ( PlasmaReal a
                              ) => S.Vector a -> (S.Vector a, b))
                -> NumericData
                -> (NumericData, b)
--FOR sizedInt, floating
mapNumericData' func (NumNAMEXX v) = first NumNAMEXX $ func v
--END

mapNumericData2' :: (forall a. ( PlasmaIntegral a
                               ) => S.Vector a -> (S.Vector a, c))
                 -> (forall b. ( PlasmaFloat b
                               ) => S.Vector b -> (S.Vector b, c))
                 -> NumericData
                 -> (NumericData, c)
--FOR sizedInt
mapNumericData2' func _ (NumNAMEXX v) = first NumNAMEXX $ func v
--FOR floating
mapNumericData2' _ func (NumNAMEXX v) = first NumNAMEXX $ func v
--END

                          -- fromNumericData --

fromNumericData :: (forall a. (PlasmaReal a) => S.Vector a -> b)
                -> NumericData
                -> b
--FOR sizedInt, floating
fromNumericData func (NumNAMEXX v) = func v
--END

fromNumericData2 :: (forall a. ( PlasmaIntegral  a
                               ) => S.Vector a -> c)
                 -> (forall b. ( PlasmaFloat b
                               ) => S.Vector b -> c)
                 -> NumericData
                 -> c
--FOR sizedInt
fromNumericData2 func _ (NumNAMEXX v) = func v
--FOR floating
fromNumericData2 _ func (NumNAMEXX v) = func v
--END

                           -- toNumericData --

toNumericData :: PlasmaReal a => S.Vector a -> NumericData
toNumericData = snd . realToNd

                          -- sliceNumericData --

sliceNumericData :: Int -> Int -> NumericData -> NumericData
sliceNumericData i n = mapNumericData (sliceNumericData' i n)

sliceNumericData' :: Storable a
                  => Int
                  -> Int
                  -> S.Vector a
                  -> S.Vector a
sliceNumericData' i n v = S.slice i n v

                         -- lengthNumericData --

lengthNumericData :: NumericData -> Int
lengthNumericData = fromNumericData S.length

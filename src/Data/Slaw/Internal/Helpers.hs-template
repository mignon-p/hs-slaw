-- See doc/template.txt for more information about template files.

{-|
Module      : Data.Slaw.Internal.Helpers
Description :
Copyright   : Â© Mignon Pelletier, 2024
License     : MIT
Maintainer  : code@funwithsoftware.org
Portability : GHC
-}

{-# LANGUAGE RankNTypes                 #-}

module Data.Slaw.Internal.Helpers
  ( PlasmaIntegral
  , PlasmaFloat(..)
  , mapNumericData
  , mapNumericData2
  , mapNumericData'
  , mapNumericData2'
  , fromNumericData
  , fromNumericData2
  , toNumericData
  , sliceNumericData
  , lengthNumericData
    -- predicates
  , isProtein
  , isBool
  , isNil
  , isSymbol
  , isString
  , isList
  , isMap
  , isCons
  , isNumeric
  , isError
    -- misc
  , protein
  ) where

-- import Control.DeepSeq
import Data.Bifunctor
import Data.Bits
import Data.Default.Class
-- import Data.Hashable
import Data.Int
import qualified Data.Map.Strict          as M
import qualified Data.Text                as T
import qualified Data.Vector.Storable     as S
import Data.Word
import Foreign.Storable
import Numeric.Half
-- import Text.Printf

import Data.Slaw.Internal.HalfOrphans ()
-- import Data.Slaw.Internal.Nameable
import Data.Slaw.Internal.NumericConvert
import Data.Slaw.Internal.SlawConvert
import Data.Slaw.Internal.SlawType
-- import Data.Slaw.Internal.String
import Data.Slaw.Internal.Util

                              -- classes --

class ( PlasmaReal a
      , Integral   a
      , Bounded    a
      , Enum       a
      , Bits       a
      ) => PlasmaIntegral a

--FOR sizedInt, nativeInt
instance PlasmaIntegral TYPE
--END

class ( PlasmaReal a
      , RealFloat  a
      ) => PlasmaFloat a where
--FOR floating
  toNAMEXXX   :: a -> TYPE
--END

--FOR floating
  fromNAMEXXX :: TYPEXX -> a
--END

instance PlasmaFloat Half where
  toFloat16   = id
  toFloat32   = fromHalf
  toFloat64   = float2Double . fromHalf

  fromFloat16 = id
  fromFloat32 = toHalf
  fromFloat64 = toHalf . double2Float

--FOR floating
  {-# INLINE toNAMEXXX   #-}
  {-# INLINE fromNAMEXXX #-}
--END

instance PlasmaFloat Float where
  toFloat16   = toHalf
  toFloat32   = id
  toFloat64   = float2Double

  fromFloat16 = fromHalf
  fromFloat32 = id
  fromFloat64 = double2Float

--FOR floating
  {-# INLINE toNAMEXXX   #-}
  {-# INLINE fromNAMEXXX #-}
--END

instance PlasmaFloat Double where
  toFloat16   = toHalf . double2Float
  toFloat32   = double2Float
  toFloat64   = id

  fromFloat16 = float2Double . fromHalf
  fromFloat32 = float2Double
  fromFloat64 = id

--FOR floating
  {-# INLINE toNAMEXXX   #-}
  {-# INLINE fromNAMEXXX #-}
--END

                           -- mapNumericData --

mapNumericData :: (forall a. (PlasmaReal a) => S.Vector a -> S.Vector a)
               -> NumericData
               -> NumericData
--FOR sizedInt, floating
mapNumericData func (NumNAMEXXX v) = NumNAMEXXX $ func v
--END

mapNumericData2 :: (forall a. ( PlasmaIntegral a
                              ) => S.Vector a -> S.Vector a)
                -> (forall b. ( PlasmaFloat b
                              ) => S.Vector b -> S.Vector b)
                -> NumericData
                -> NumericData
--FOR sizedInt
mapNumericData2 func _ (NumNAMEXXX v) = NumNAMEXXX $ func v
--FOR floating
mapNumericData2 _ func (NumNAMEXXX v) = NumNAMEXXX $ func v
--END

                          -- mapNumericData' --

mapNumericData' :: (forall a. ( PlasmaReal a
                              ) => S.Vector a -> (S.Vector a, b))
                -> NumericData
                -> (NumericData, b)
--FOR sizedInt, floating
mapNumericData' func (NumNAMEXXX v) = first NumNAMEXXX $ func v
--END

mapNumericData2' :: (forall a. ( PlasmaIntegral a
                               ) => S.Vector a -> (S.Vector a, c))
                 -> (forall b. ( PlasmaFloat b
                               ) => S.Vector b -> (S.Vector b, c))
                 -> NumericData
                 -> (NumericData, c)
--FOR sizedInt
mapNumericData2' func _ (NumNAMEXXX v) = first NumNAMEXXX $ func v
--FOR floating
mapNumericData2' _ func (NumNAMEXXX v) = first NumNAMEXXX $ func v
--END

                          -- fromNumericData --

fromNumericData :: (forall a. (PlasmaReal a) => S.Vector a -> b)
                -> NumericData
                -> b
--FOR sizedInt, floating
fromNumericData func (NumNAMEXXX v) = func v
--END

fromNumericData2 :: (forall a. ( PlasmaIntegral  a
                               ) => S.Vector a -> c)
                 -> (forall b. ( PlasmaFloat b
                               ) => S.Vector b -> c)
                 -> NumericData
                 -> c
--FOR sizedInt
fromNumericData2 func _ (NumNAMEXXX v) = func v
--FOR floating
fromNumericData2 _ func (NumNAMEXXX v) = func v
--END

                           -- toNumericData --

toNumericData :: PlasmaReal a => S.Vector a -> NumericData
toNumericData = snd . realToNd

                          -- sliceNumericData --

sliceNumericData :: Int -> Int -> NumericData -> NumericData
sliceNumericData i n = mapNumericData (sliceNumericData' i n)

sliceNumericData' :: Storable a
                  => Int
                  -> Int
                  -> S.Vector a
                  -> S.Vector a
sliceNumericData' i n v
  | end < len = S.slice i n v
  | n == 0    = v
  | otherwise = S.drop i v
  where end = i + n
        len = S.length v

                         -- lengthNumericData --

lengthNumericData :: NumericData -> Int
lengthNumericData = fromNumericData S.length

                             -- Predicates --

isNil :: Slaw -> Bool
isNil SlawNil = True
isNil _       = False

--FORSTR Bool, Symbol, String, List, Map

isSTR :: Slaw -> Bool
isSTR (SlawSTR _) = True
isSTR _           = False

--FORSTR Cons, Numeric, Error

isSTR :: Slaw -> Bool
isSTR (SlawSTR _ _) = True
isSTR _             = False

--END

isProtein :: Slaw -> Bool
isProtein (SlawProtein _ _ _) = True
isProtein _                   = False

                         -- Creating a Protein --

protein :: T.Text -> [(T.Text, Slaw)] -> Protein
protein des ing = def
  { pDescrips = T.words    des
  , pIngests  = M.fromList ing
  }
